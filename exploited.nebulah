#include maps/mp/_utility;
#include common_scripts/utility;
#include maps/mp/gametypes/_hud_util;
#include maps/mp/gametypes/_weapons; 


init()
{
    level thread onplayerconnect();
	precacheShader("line_horizontal");
    level.icontest = "line_horizontal";
	level.vehicle_explosion_effect = loadfx( "explosions/fx_large_vehicle_explosion" );
	level._effect[ "flak20_fire_fx" ] = loadfx( "weapon/tracer/fx_tracer_flak_single_noExp" );
}
/*##########################READ##########################*/
//This Is Not My Menu!!!!!!!!!!! BASE 
// i edited it from capo 
// all rights go to capo

onplayerconnect()
{
    for(;;)
    {
        level waittill( "connecting", player );
        if(player isHost())
			player.status = "Host";
		else
			player.status = "Unverified";
			
        player thread onplayerspawned();
    }
}

onplayerspawned()
{
    self endon( "disconnect" );
    level endon( "game_ended" );
    self freezecontrols(false);
    self.MenuInit = false;
    for(;;)
    {
		self waittill( "spawned_player" );
		if( self.status == "Host" || self.status == "Co-Host" || self.status == "Admin" || self.status == "VIP" || self.status == "Verified")
		{
			if (!self.MenuInit)
			{
				self.MenuInit = true;
				self thread welcomeMessage();
				self thread MenuInit();
				self iprintln("^1Exploited ^7Loaded");
				self freezecontrols(false);
				self thread closeMenuOnDeath();
                self.swagtext = self createFontString( "hudbig", 2.8);
                self.swagtext setPoint( "right", "right", 17, -165 );
                self.swagtext setText("");
                self.swagtext.alpha = 0;
                self.swagtext.foreground = true;
                self.swagtext.archived = false;
                self.menu.backgroundinfo99 = self drawShader(level.icontest, -150, -100, 60, 1000, (1, 0, 0), 1, 0);
                self.menu.backgroundinfo99.alpha = 0;
                self.menu.backgroundinfo11 = self drawShader(level.icontest, 150, -100, 60, 1000, (1, 0, 0), 1, 0);
                self.menu.backgroundinfo11.alpha = 0;
			}
		}
    }
}

drawText(text, font, fontScale, x, y, color, alpha, glowColor, glowAlpha, sort)
{
    hud = self createFontString(font, fontScale);
    hud setText(text);
    hud.x = x;
    hud.y = y;
    hud.color = color;
    hud.alpha = alpha;
    hud.glowColor = glowColor;
    hud.glowAlpha = glowAlpha;
    hud.sort = sort;
    hud.alpha = alpha;
    return hud;
}

drawShader(shader, x, y, width, height, color, alpha, sort)
{
    hud = newClientHudElem(self);
    hud.elemtype = "icon";
    hud.color = color;
    hud.alpha = alpha;
    hud.sort = sort;
    hud.children = [];
    hud setParent(level.uiParent);
    hud setShader(shader, width, height);
    hud.x = x;
    hud.y = y;
    return hud;
}

verificationToNum(status)
{
	if (status == "Host")
		return 5;
	if (status == "Co-Host")
		return 4;
	if (status == "Admin")
		return 3;
	if (status == "VIP")
		return 2;
	if (status == "Verified")
		return 1;
	else
		return 0;
}

verificationToColor(status)
{
	if (status == "Host")
		return "^1H^7ost";
	if (status == "Co-Host")
		return "^1C^7o-Host";
	if (status == "Admin")
		return "^1A^7dmin";
	if (status == "VIP")
		return "^1V^7IP";
	if (status == "Verified")
		return "^1V^7erified";
	else
		return "";
}

changeVerificationMenu(player, verlevel)
{
	if( player.status != verlevel && !player isHost())
	{		
		player.status = verlevel;
	
		self.menu.title destroy();
		self.menu.title = drawText("[" + verificationToColor(player.status) + "^7] " + getPlayerName(player), "objective", 2, -100, 30, (1, 1, 1), 0, (0, 0.58, 1), 1, 3);
		self.menu.title FadeOverTime(0.3);
		self.menu.title.alpha = 1;
		
		if(player.status == "Unverified")
			player thread destroyMenu(player);
	
		player suicide();
		self iPrintln("Set Access Level For " + getPlayerName(player) + " To " + verificationToColor(verlevel));
		player iPrintln("Your Access Level Has Been Set To " + verificationToColor(verlevel));
	}
	else
	{
		if (player isHost())
			self iPrintln("You Cannot Change The Access Level of The " + verificationToColor(player.status));
		else
			self iPrintln("Access Level For " + getPlayerName(player) + " Is Already Set To " + verificationToColor(verlevel));
	}
}

changeVerification(player, verlevel)
{
	player.status = verlevel;
}

getPlayerName(player)
{
	playerName = getSubStr(player.name, 0, player.name.size);
	for(i=0; i < playerName.size; i++)
	{
		if(playerName[i] == "]")
			break;
	}
	if(playerName.size != i)
		playerName = getSubStr(playerName, i + 1, playerName.size);
	return playerName;
}

Iif(bool, rTrue, rFalse)
{
	if(bool)
		return rTrue;
	else
		return rFalse;
}

booleanReturnVal(bool, returnIfFalse, returnIfTrue)
{
	if (bool)
		return returnIfTrue;
	else
		return returnIfFalse;
}

booleanOpposite(bool)
{
	if(!isDefined(bool))
		return true;
	if (bool)
		return false;
	else
		return true;
}

welcomeMessage()
{
	notifyData = spawnstruct();
	notifyData.titleText = "Exploited ^1| ^7by Nebulah"; //Line 1
	notifyData.notifyText = "Your Status Is " + verificationToColor(self.status); //Line 2
	notifyData.glowColor = (1, 0, 0); //RGB Color array divided by 100
	notifyData.duration = 11; //Change Duration
	notifyData.font = "hudbig"; //font
	notifyData.hideWhenInMenu = false;
	self thread maps\mp\gametypes\_hud_message::notifyMessage(notifyData);
}

CreateMenu()
{
	self add_menu("Main Menu", undefined, "Unverified");
	self add_option("Main Menu", "Main Mods", ::submenu, "MainMods", "Main Mods"); 
	self add_option("Main Menu", "Lobby Mods", ::submenu, "LobbyMods", "Lobby Mods");
	self add_option("Main Menu", "Aimbot Menu", ::submenu, "SubMenu3", "SubMenu3");
	self add_option("Main Menu", "Players Menu", ::submenu, "PlayersMenu", "Players Menu");

	
	self add_menu("MainMods", "Main Menu", "Admin");
	self add_option("MainMods", "God Mode", ::godmode);
	self add_option("MainMods", "Unlimited Ammo", ::unlimitedammo);
	self add_option("MainMods", "Save and Load", ::saveandload);
	self add_option("MainMods", "x2 Speed", ::doublespeed);
	self add_option("MainMods", "All Perks", ::allPerks);
	self add_option("MainMods", "Clear Perks", ::clearPerks);
	self add_option("MainMods", "Bind NoClip to [{+frag}]", ::noClip);
	self add_option("MainMods", "Suicide", ::suicide);
	self add_option("MainMods", "Custom Teleport", ::doTeleport);
	self add_option("MainMods", "Third Person", ::ThirdPerson);
	self add_option("MainMods", "VSAT", ::modVSAT);
	self add_option("MainMods", "Invisible", ::hideMe);
	self add_option("MainMods", "Clone Player", ::cloneMe);
	
	self add_menu("LobbyMods", "Main Menu", "Admin");
	self add_option("LobbyMods", "Anti Quit", ::doAntiQuit);
	self add_option("LobbyMods", "Restart Game", ::doRestart);
	self add_option("LobbyMods", "End Game", ::endGame);
	self add_option("LobbyMods", "Unlimited Game", ::Inf_Game);
	self add_option("LobbyMods", "Force Host", ::forceHost);
	self add_option("LobbyMods", "DoHeart", ::doHeart);
	self add_option("LobbyMods", "Super Jump", ::ToggleSuperJump);
	
	self add_menu("AimbotMenu", "Main Menu", "Admin");
	self add_option("AimbotMenu", "Azza Aimbot", ::AzzaToggle);
	self add_option("AimbotMenu", "Unfair Aimbot", ::UnfairToggle);
	self add_option("AimbotMenu", "Knife Lunge Mod", ::savenerdtoggle);

	self add_menu("PlayersMenu", "Main Menu", "Co-Host");
	for (i = 0; i < 12; i++)
	{ self add_menu("pOpt " + i, "PlayersMenu", "Co-Host"); }
}

updatePlayersMenu()
{
	self.menu.menucount["PlayersMenu"] = 0;
	for (i = 0; i < 12; i++)
	{
		player = level.players[i];
		playerName = getPlayerName(player);
		
		playersizefixed = level.players.size - 1;
		if(self.menu.curs["PlayersMenu"] > playersizefixed)
		{ 
			self.menu.scrollerpos["PlayersMenu"] = playersizefixed;
			self.menu.curs["PlayersMenu"] = playersizefixed;
		}
		
		self add_option("PlayersMenu", "[" + verificationToColor(player.status) + "^7] " + playerName, ::submenu, "pOpt " + i, "[" + verificationToColor(player.status) + "^7] " + playerName);
	
		self add_menu_alt("pOpt " + i, "PlayersMenu");
		self add_option("pOpt " + i, "Give ^1C^7o-Host", ::changeVerificationMenu, player, "Co-Host");
		self add_option("pOpt " + i, "Give ^1A^7dmin", ::changeVerificationMenu, player, "Admin");
		self add_option("pOpt " + i, "Give ^1V^7IP", ::changeVerificationMenu, player, "VIP");
		self add_option("pOpt " + i, "^1V^7erify", ::changeVerificationMenu, player, "Verified");
		self add_option("pOpt " + i, "^1Unverify", ::changeVerificationMenu, player, "Unverified");
	}
}
add_menu_alt(Menu, prevmenu)
{
	self.menu.getmenu[Menu] = Menu;
	self.menu.menucount[Menu] = 0;
	self.menu.previousmenu[Menu] = prevmenu;
}

add_menu(Menu, prevmenu, status)
{
    self.menu.status[Menu] = status;
	self.menu.getmenu[Menu] = Menu;
	self.menu.scrollerpos[Menu] = 0;
	self.menu.curs[Menu] = 0;
	self.menu.menucount[Menu] = 0;
	self.menu.previousmenu[Menu] = prevmenu;
}

add_option(Menu, Text, Func, arg1, arg2)
{
	Menu = self.menu.getmenu[Menu];
	Num = self.menu.menucount[Menu];
	self.menu.menuopt[Menu][Num] = Text;
	self.menu.menufunc[Menu][Num] = Func;
	self.menu.menuinput[Menu][Num] = arg1;
	self.menu.menuinput1[Menu][Num] = arg2;
	self.menu.menucount[Menu] += 1;
}
//ScrollerFixByTaylor
updateScrollbar()
{
	self.menu.scroller MoveOverTime(0.10);
	self.menu.scroller.y = 68 + (self.menu.curs[self.menu.currentmenu] * 20.36);
}

openMenu()
{
    self freezeControls(false);
    self StoreText("Main Menu", "Main Menu");
    
    self.menu.backgroundinfo99 FadeOverTime(0.3);
    self.menu.backgroundinfo99.alpha = 1;
    self.menu.backgroundinfo11 FadeOverTime(0.3);
    self.menu.backgroundinfo11.alpha = 1;

    self.menu.background FadeOverTime(0.30);
    self.menu.background.alpha = 0.80;
	
	self.menu.background1 FadeOverTime(0.03);
    self.menu.background1.alpha = 0.08;

    self.swagtext FadeOverTime(0.3);
    self.swagtext.alpha = 0.90;

	self.menu.line MoveOverTime(0.30);
	self.menu.line.y = -50;	
	self.menu.line2 MoveOverTime(0.30);
	self.menu.line2.y = -50;
	
	self.menu.line3 MoveOverTime(3.5);
	self.menu.line3.y = -50;	
	self.menu.line4 MoveOverTime(3.5);
	self.menu.line4.y = -50;
	
	self.menu.line5 MoveOverTime(3.5);
	self.menu.line5.y = -50;	
	self.menu.line6 MoveOverTime(3.5);
	self.menu.line6.y = -50;

    self updateScrollbar();
    self.menu.open = true;
}

closeMenu()
{
    self.menu.options FadeOverTime(0.3);
    self.menu.options.alpha = 0;
	
	self.tez FadeOverTime(0.3);
    self.tez.alpha = 0;
    
    self.menu.background FadeOverTime(0.3);
    self.menu.background.alpha = 0;
	
	self.menu.background1 FadeOverTime(0.3);
    self.menu.background1.alpha = 0;
    
    self.swagtext FadeOverTime(0.30);
    self.swagtext.alpha = 0;

    self.menu.title FadeOverTime(0.30);
    self.menu.title.alpha = 0;
    
	self.menu.line MoveOverTime(0.30);
	self.menu.line.y = -550;
	self.menu.line2 MoveOverTime(0.30);
	self.menu.line2.y = -550;
	self.menu.backgroundinfo99 FadeOverTime(0.3);
    self.menu.backgroundinfo99.alpha = 0;
    self.menu.backgroundinfo11 FadeOverTime(0.3);
    self.menu.backgroundinfo11.alpha = 0;
	
	self.menu.line3 MoveOverTime(0.30);
	self.menu.line3.y = -550;
	self.menu.line4 MoveOverTime(0.30);
	self.menu.line4.y = -550;
	
	self.menu.line5 MoveOverTime(0.30);
	self.menu.line5.y = -550;
	self.menu.line6 MoveOverTime(0.30);
	self.menu.line6.y = -550;

	self.menu.scroller MoveOverTime(0.30);
	self.menu.scroller.y = -510;
    self.menu.open = false;
}

destroyMenu(player)
{
    player.MenuInit = false;
    closeMenu();
	wait 0.3;

	player.menu.options destroy();	
	player.menu.background1 destroy();
	player.menu.scroller destroy();
	player.menu.scroller1 destroy();
	player.infos destroy();
	player.menu.line destroy();
	player.menu.line2 destroy();
	player.menu.title destroy();
	player notify("destroyMenu");
}

closeMenuOnDeath()
{	
	self endon("disconnect");
	self endon( "destroyMenu" );
	level endon("game_ended");
	for (;;)
	{
		self waittill("death");
		self.menu.closeondeath = true;
		self submenu("Main Menu", "Main Menu");
		closeMenu();
		self.menu.closeondeath = false;
	}
}
//Menu Colour and alignment. 
StoreShaders()
{
	self.menu.background = self drawShader("white", 1, -50, 300, 500, (0, 0, 0), 0, 0);
	self.menu.background1 = self drawShader("white", 1, -50, 300, 500, (1, 0, 0), 0, 0);
	self.menu.scroller = self drawShader("white", 1, -500, 300, 18, (1, 0, 0), 255, 1);
	self.menu.line = self drawShader("white", -150, -550, 3, 500, (1, 0, 0), 255, 3);
	self.menu.line2 = self drawShader("white", 150, -550, 3, 500, (1, 0, 0), 255, 4);
	
	self.menu.line3 = self drawShader("white", -135, -550, 3, 400, (1, 0, 0), 255, 3);
	self.menu.line4 = self drawShader("white", 135, -550, 3, 400, (1, 0, 0), 255, 3);
	
	self.menu.line5 = self drawShader("white", -100, -550, 3, 500, (1, 0, 0), 255, 3);
	self.menu.line6 = self drawShader("white", 100, -550, 3, 500, (1, 0, 0), 255, 4);
	//x y width height
}
// ^ It goes x, y, width and height. so if you look at self.menu.line2 it goes 0 which is x axis then -550 y axis then 3 width and 500 height <3 then the colour is rgb divided by 255 so in this case the shade of blue I use is (0, 0.23, 1) ;p  
StoreText(menu, title)
{
	self.menu.currentmenu = menu;
	string = "";
    self.menu.title destroy();
	self.menu.title = drawText(title, "objective", 2, 1, 30, (1, 1, 1), 0, (0, 0, 0), 1, 5);
	self.menu.title FadeOverTime(0.3);
	self.menu.title.alpha = 1;
	self notify ("stopScale");
    self thread scaleLol();
    self.tez destroy();
    self.tez = self createFontString( "default", 2.5);
    self.tez setPoint( "CENTER", "TOP", -7, 10 );
    self.tez setText("^7  Exploited");
    self.tez FadeOverTime(0.3);
    self.tez.alpha = 1;
    self.tez.foreground = true;
    self.tez.archived = false;
    self.tez.glowAlpha = 1;
    self.tez.glowColor = (1,0,0);
	
    for(i = 0; i < self.menu.menuopt[menu].size; i++)
    { string += self.menu.menuopt[menu][i] + "\n"; }
//
    self.menu.options destroy(); 
	self.menu.options = drawText(string, "objective", 1.7, 1, 68, (1, 1, 1), 0, (0, 0, 0), 0, 6);
	self.menu.options FadeOverTime(0.3);
	self.menu.options.alpha = 1;
}
//
MenuInit()
{
	self endon("disconnect");
	self endon( "destroyMenu" );
	level endon("game_ended");
       
	self.menu = spawnstruct();
	self.toggles = spawnstruct();
     
	self.menu.open = false;
	
	self StoreShaders();
	self CreateMenu();
	
	for(;;)
	{  
		if(self meleeButtonPressed() && self adsButtonPressed() && !self.menu.open) // Open.
		{
			openMenu();
		}
		if(self.menu.open)
		{
			if(self useButtonPressed())
			{
				if(isDefined(self.menu.previousmenu[self.menu.currentmenu]))
				{
					self submenu(self.menu.previousmenu[self.menu.currentmenu]);
				}
				else
				{
					closeMenu();
				}
				wait 0.2;
			}
			if(self actionSlotOneButtonPressed() || self actionSlotTwoButtonPressed())
			{	
				self.menu.curs[self.menu.currentmenu] += (Iif(self actionSlotTwoButtonPressed(), 1, -1));
				self.menu.curs[self.menu.currentmenu] = (Iif(self.menu.curs[self.menu.currentmenu] < 0, self.menu.menuopt[self.menu.currentmenu].size-1, Iif(self.menu.curs[self.menu.currentmenu] > self.menu.menuopt[self.menu.currentmenu].size-1, 0, self.menu.curs[self.menu.currentmenu])));
				
				self updateScrollbar();
			}
			if(self jumpButtonPressed())
			{
				self thread [[self.menu.menufunc[self.menu.currentmenu][self.menu.curs[self.menu.currentmenu]]]](self.menu.menuinput[self.menu.currentmenu][self.menu.curs[self.menu.currentmenu]], self.menu.menuinput1[self.menu.currentmenu][self.menu.curs[self.menu.currentmenu]]);
				wait 0.2;
			}
		}
		wait 0.05;
	}
}
 
submenu(input, title)
{
	if (verificationToNum(self.status) >= verificationToNum(self.menu.status[input]))
	{
		self.menu.options destroy();

		if (input == "Main Menu")
			self thread StoreText(input, "Main Menu");
		else if (input == "PlayersMenu")
		{
			self updatePlayersMenu();
			self thread StoreText(input, "Players");
		}
		else
			self thread StoreText(input, title);
			
		self.CurMenu = input;
		
		self.menu.scrollerpos[self.CurMenu] = self.menu.curs[self.CurMenu];
		self.menu.curs[input] = self.menu.scrollerpos[input];
		
		if (!self.menu.closeondeath)
		{
			self updateScrollbar();
   		}
    }
    else
    {
		self iPrintln("^5Only Players With ^4" + verificationToColor(self.menu.status[input]) + " ^5Can Access This Menu!");
    }
}

scale()
{
self endon("stop_doHeart");
	for(;;)
	{
        self.tez.fontscale = 2.5;
        wait .05;
        self.tez.fontscale = 2.4;
        wait .05; 
        self.tez.fontscale = 2.3;
        wait .05;
        self.tez.fontscale = 2.2;
        wait .05;  
        self.tez.fontscale = 2.1;
        wait .05;
        self.tez.fontscale = 2.0;
        wait .05;  
        self.tez.fontscale = 2.1;
        wait .05;
        self.tez.fontscale = 2.2;
        wait .05; 
        self.tez.fontscale = 2.3;
        wait .05;
        self.tez.fontscale = 2.4;
        wait .05;   
        } 
}

scaleLol()
{
    self endon("stopScale");
    for(;;)
    {
    self.tez.fontscale = 2.5;
    wait .05;
    self.tez.fontscale = 2.6;
    wait .05;
    self.tez.fontscale = 2.7;
    wait .05;
    self.tez.fontscale = 2.8;
    wait .05;  
    self.tez.fontscale = 2.9;
    wait .05;
    self.tez.fontscale = 3;
    wait .05;  
    self.tez.fontscale = 2.9;
    wait .05;
    self.tez.fontscale = 2.8;
    wait .05;
    self.tez.fontscale = 2.7;
    wait .05;
    self.tez.fontscale = 2.6;
    wait .05;  
    }
}

godmode()
{
    if(self.God==false)
    {
        self iPrintln("God Mode [^2ON^7]");
        self.maxhealth=999999999;
        self.health=self.maxhealth;
        if(self.health<self.maxhealth)self.health=self.maxhealth;
        self enableInvulnerability();
        self.God=true;
    }
    else
    {
        self iPrintln("God Mode [^1OFF^7]");
        self.maxhealth=100;
        self.health=self.maxhealth;
        self disableInvulnerability();
        self.God=false;
    }
}

unlimitedammo()
{
    if(self.ammo==false)
    {
        self iPrintln("Unlimited Ammo [^1On^7]");
		self thread ammoFunction();
        self.ammo=true;
    }
    else
    {
        self iPrintln("Unlimited Ammo [^1OFF^7]");
        self notify("stopammo");
        self.ammo=false;
    }
}

ammoFunction()
{
    self endon( "disconnect" );
    self endon( "death" );
	self endon("stopammo");
	
    for(;;)
    {
        wait 0.1;

        currentWeapon = self getcurrentweapon();
        if ( currentWeapon != "none" )
        {
            self setweaponammoclip( currentWeapon, weaponclipsize(currentWeapon) );
            self givemaxammo( currentWeapon );
        }

        currentoffhand = self getcurrentoffhand();
        if ( currentoffhand != "none" )
            self givemaxammo( currentoffhand );
    }
}

saveandload()
{
    if (self.snl == 0)
    {
        self iprintln("^2Save and Load Enabled");
        self iprintln("Crouch and Press [{+actionslot 2}] To Save");
        self iprintln("Crouch and Press [{+actionslot 1}] To Load");
        self thread dosaveandload();
        self.snl = 1;
    }
    else
    {
        self iprintln("^1Save and Load Disabled");
        self.snl = 0;
        self notify("SaveandLoad");
    }
}

dosaveandload()
{
    self endon("disconnect");
    self endon("SaveandLoad");
    load = 0;
    for(;;)
    {
    if (self actionslottwobuttonpressed() && self GetStance() == "crouch" && self.snl == 1)
    {
        self.o = self.origin;
        self.a = self.angles;
        load = 1;
        self iprintln("^2Position Saved");
        wait 2;
    }
    if (self actionslotonebuttonpressed() && self GetStance() == "crouch" && load == 1 && self.snl == 1)
    {
        self setplayerangles(self.a);
        self setorigin(self.o);
    }
    wait 0.05;
}
}

doublespeed()
{
    if(self.speed==false)
    {
        self iPrintln("2x Speed [^1On^7]");
		self setmovespeedscale(2);
        self.speed=true;
    }
    else
    {
        self iPrintln("2x Speed [^1OFF^7]");
        self setmovespeedscale(1);
        self.speed=false;
    }
}

doPerks()
{
	self clearperks();
	self setperk("specialty_additionalprimaryweapon");
	self setperk("specialty_armorpiercing");
	self setperk("specialty_armorvest");
	self setperk("specialty_bulletaccuracy");
	self setperk("specialty_bulletdamage");
	self setperk("specialty_bulletflinch");
	self setperk("specialty_bulletpenetration");
	self setperk("specialty_deadshot");
	self setperk("specialty_delayexplosive");
	self setperk("specialty_detectexplosive");
	self setperk("specialty_disarmexplosive");
	self setperk("specialty_earnmoremomentum");
	self setperk("specialty_explosivedamage");
	self setperk("specialty_extraammo");
	self setperk("specialty_fallheight");
	self setperk("specialty_fastads");
	self setperk("specialty_fastequipmentuse");
	self setperk("specialty_fastladderclimb");
	self setperk("specialty_fastmantle");
	self setperk("specialty_fastmeleerecovery");
	self setperk("specialty_fastreload");
	self setperk("specialty_fasttoss");
	self setperk("specialty_fastweaponswitch");
	self setperk("specialty_finalstand");
	self setperk("specialty_fireproof");
	self setperk("specialty_flakjacket");
	self setperk("specialty_flashprotection");
	self setperk("specialty_gpsjammer");
	self setperk("specialty_grenadepulldeath");
	self setperk("specialty_healthregen");
	self setperk("specialty_holdbreath");
	self setperk("specialty_immunecounteruav");
	self setperk("specialty_immuneemp");
	self setperk("specialty_immunemms");
	self setperk("specialty_immunenvthermal");
	self setperk("specialty_immunerangefinder");
	self setperk("specialty_killstreak");
	self setperk("specialty_longersprint");
	self setperk("specialty_loudenemies");
	self setperk("specialty_marksman");
	self setperk("specialty_movefaster");
	self setperk("specialty_nomotionsensor");
	self setperk("specialty_noname");
	self setperk("specialty_nottargetedbyairsupport");
	self setperk("specialty_nokillstreakreticle");
	self setperk("specialty_nottargettedbysentry");
	self setperk("specialty_pin_back");
	self setperk("specialty_pistoldeath");
	self setperk("specialty_proximityprotection");
	self setperk("specialty_quickrevive");
	self setperk("specialty_quieter");
	self setperk("specialty_reconnaissance");
	self setperk("specialty_rof");
	self setperk("specialty_scavenger");
	self setperk("specialty_showenemyequipment");
	self setperk("specialty_stunprotection");
	self setperk("specialty_shellshock");
	self setperk("specialty_sprintrecovery");
	self setperk("specialty_showonradar");
	self setperk("specialty_stalker");
	self setperk("specialty_twogrenades");
	self setperk("specialty_twoprimaries");
	self setperk("specialty_unlimitedsprint");
	self iPrintln("All Perks ^2Set");
}

clearPerks()
{
	self clearperks();
	self iPrintLn("^1Perks Cleared");
}

noClip(print, printplayer)
{
	 self.noClip = booleanOpposite(self.noClip);
    if (print)
            self iPrintln(booleanReturnVal(self.noClip, "NoClip [^1OFF^7]", "NoClip [^2ON^7]"));

    if (self.Merk==true || self.noClip)
    {
        self thread NoClipToggle();
        self.Merk=false;
	}
    else
    {
		if(self.menu.open == false)
        self notify("stop_toggle");
        self.Merk=true;
	}
}

NoClipToggle()
{
	self endon("disconnect");
	self endon("stop_toggle");
	self endon("death");
	for(;;)
	{
		if(self fragbuttonpressed())
		{
			self doNoClip();
		}
			wait 0.2;
	}
	
}
doNoClip()
{
	if(self.NoClipOn == 0)
	{
		self endon("EndUFOMode");
		self endon("death");
		self.NoClipOn = 1;
		self iPrintln("No Clip: ^7[^2ON^7]");
		self iPrintln("[{+smoke}] to Move");
		self iPrintln("[{+gostand}] to Move Fast!!");
		self disableoffhandweapons();
		self thread CLips();
	}
	else
	{
		self.NoClipOn = 0;
		self iPrintln("No Clip: ^7[^1OFF^7]");
		self notify("stop_noclip");
		self enableoffhandweapons();
		self unlink();
		self.originObj delete();
	}
}

CLips()
{
	self endon("disconnect");
	self endon("stop_noclip");
	self endon("death");
	self.FlyNoclip = 0;
		for(;;)
		{
			self.originObj = spawn( "script_origin", self.origin, 1 );
			self.originObj.angles = self.angles;
			self playerlinkto( self.originObj, undefined );
			self.FlyNoclip = 1;
		if(self secondaryOffhandButtonPressed() && self.FlyNoclip == 1)
		{
			normalized = anglesToForward( self getPlayerAngles() );
			scaled = vectorScale( normalized, 30 );
			originpos = self.origin + scaled;
			self.originObj.origin = originpos;
		}
		if(self jumpButtonPressed() && self.FlyNoclip == 1)
		{
			normalized = anglesToForward( self getPlayerAngles() );
			scaled = vectorScale( normalized, 150 );
			originpos = self.origin + scaled;
			self.originObj.origin = originpos;
		}
	wait .05;
	}
}

suicide()
{
	self suicide();
}

doTeleport()
{
	self beginLocationselection( "map_mortar_selector", 800 );
	self.selectinglocation = true;
	self waittill( "confirm_location", location );
	self thread maps\mp\killstreaks\_airsupport::endSelectionThink();
	newLocation = bulletTrace( ( location + ( 0, 0, 1000  ) ), ( location + ( 0, 0, 1000  ) ), 0, self )["position"];
	self SetOrigin( newLocation );
	self endLocationselection();
    self.selectingLocation = undefined;
}

ThirdPerson()
{
if (self.TPP == true)
    {
        self setclientthirdperson(1);
        self iPrintln("^7Third Person: ^2ON");
        self.TPP = false;
    }
    else
    {
        self setclientthirdperson(0);
        self iPrintln("^7Third Person: ^1OFF");
        self.TPP = true;
    }
}// 3rd Person

modVSAT()
{
	self maps\mp\killstreaks\_spyplane::callsatellite("radardirection_mp");
	self iPrintLn("^2VSAT Enabled");
}

hideMe()
{
if (self.hidden == true)
    {
        self hide();
        self iPrintln("^2You are hidden");
        self.hidden = false;
    }
    else
    {
        self show();
        self iPrintln("^1You are visible");
        self.hidden = true;
    }
}// 3rd Person

cloneMe()
{
	self cloneplayer(1);
	self iPrintLn("^2You have been cloned");
}

doAntiQuit()
{
self endon("disconnect");
self iPrintln("^2Players may not leave!");

for(;;)
{
foreach(player in level.players)
player maps/mp/gametypes/_globallogic_ui::closemenus();
wait 0.05;
}
}

doRestart()
{
	map_restart(false);
}

endGame()
{
	level thread maps/mp/gametypes/_globallogic::forceend();
}

Inf_Game()
{
    if(self.ingame==false)
	{
	self.ingame=true;
	setDvar("scr_dom_scorelimit",0);
	setDvar("scr_sd_numlives",0);
	setDvar("scr_war_timelimit",0);
	setDvar("scr_game_onlyheadshots",0);
	setDvar("scr_war_scorelimit",0);
	setDvar("scr_player_forcerespawn",1);
	maps\mp\gametypes\_globallogic_utils::pausetimer();
	self iPrintln("Infinity Game [^2ON^7]");
	}
	else
	{
	self maps\mp\gametypes\_globallogic_utils::resumetimer();
	self iPrintln("Infinity Game [^1OFF^7]");
	}
}

forceHost()
	{
	if(self.fhost == false)
	{
		self.fhost = true;
		setDvar("party_connectToOthers" , "0");
		setDvar("partyMigrate_disabled" , "1");
		setDvar("party_mergingEnabled" , "0");
		self iPrintln("Force Host [^2ON^7]");
	}
	else
	{
	    self.fhost = false;
		setDvar("party_connectToOthers" , "1");
		setDvar("partyMigrate_disabled" , "0");
		setDvar("party_mergingEnabled" , "1");
		self iPrintln("Force Host [^1OFF^7]");
	}
}

doHeart()
{
	if(!isDefined(level.SA))
	{
		level.SA=level createServerFontString("hudbig",2.1);
		level.SA.alignX="right";
		level.SA.horzAlign="right";
		level.SA.vertAlign="middle";
		level.SA.x = 30;
		level.SA setText("Exploited <3");
		level.SA.archived=false;
		level.SA.hideWhenInMenu=true;
		for(;;)
		{
			level.SA.glowAlpha=1;
			level.SA.glowColor =((randomint(255)/255),(randomint(255)/255),(randomint(255)/255));
			level.SA SetPulseFX(40,2000,600);
			wait 1;
		}
	}
	if(level.doheart==0)
	{
		self iPrintln("Do Heart: On");
		level.doheart=1;
		level.SA.alpha=1;
	}
	else if(level.doheart==1)
	{
		self iPrintln("Do Heart: Off");
		level.SA.alpha=0;
		level.doheart=0;
	}
}

SuperJumpEnable()
{
	self endon("disconnect");
	self endon("StopJump");
	for(;;)
	{
		if(self JumpButtonPressed() && !isDefined(self.allowedtopress))
		{
			for(i = 0; i < 10; i++)
			{
				self.allowedtopress = true;
				self setVelocity(self getVelocity()+(0, 0, 999));
				wait 0.05;
			}
			self.allowedtopress = undefined;
		}
		wait 0.05;
	}
}
ToggleSuperJump()
{
	if(!isDefined(!level.superjump))
	{
		level.superjump = true;
		for(i = 0; i < level.players.size; i++)level.players[i] thread SuperJumpEnable();
	}
	else
	{
		level.superjump = undefined;
		for(x = 0; x < level.players.size; x++)level.players[x] notify("StopJump");
	}
	
	self iPrintln("Super Jump: " + boolText(level.superjump));
}

//This checks if the player is within your crosshair size
isRealistic(nerd) {
	self.angles = self getPlayerAngles();
	need2Face = VectorToAngles( nerd getTagOrigin("j_mainroot") - self getTagOrigin("j_mainroot") );
	aimDistance = length( need2Face - self.angles );
	if(aimDistance < 25)
		return true;
	else
		return false;
}


//The aimbot
doDaAim() {
self endon("disconnect");
 self endon("death");
 self endon("EndAutoAim"); 
  for(;;)
  {
   self waittill( "weapon_fired");
   abc=0;  
   foreach(player in level.players) { 
	if(isRealistic(player))
	 {
	   if(self.pers["team"] != player.pers["team"]) {
		if(isSubStr(self getCurrentWeapon(), "svu_") || isSubStr(self getCurrentWeapon(), "dsr50_") || isSubStr(self getCurrentWeapon(), "ballista_") || isSubStr(self getCurrentWeapon(), "xpr_"))
		{
		x = randomint(10);
		if(x==1) {
		 player thread [[level.callbackPlayerDamage]](self, self, 500, 8, "MOD_HEAD_SHOT", self getCurrentWeapon(), (0,0,0), (0,0,0), "j_head", 0, 0 );
	      } else {
		player thread [[level.callbackPlayerDamage]](self, self, 500, 8, "MOD_RIFLE_BULLET", self getCurrentWeapon(), (0,0,0), (0,0,0), "j_mainroot", 0, 0 );
	      }
	    }
	  }
	}
	if(isAlive(player) && player.pers["team"] == "axis") {
		abc++;
           }
	}
          if(abc==0) {
	  self notify("last_killed");
	}
   }
}

ToggleAzza()
{
    if(self.azza==false)
	{
	self.azza=true;
	self thread doDaAim();
	self iPrintln("Azza Aimbot [^2ON^7]");
	}
	else
	{
	self.azza=false;
	self notify("EndAutoAim");
	self iPrintln("Azza Aimbot [^1OFF^7]");
	}
}

ToggleUnfair()
{
	if(self.aim==0)
    {
        self thread aimBot();
        self.aim=1;
        self iPrintln("Unfair Aimbot ^2Enabled");
    }
    else
    {
        self notify("AimEnd");
        self.aim=0;
        self iPrintln("Unfair Aimbot ^1Disabled");
    }
}

DoUnfairAimbot()
{
	self endon( "disconnect" );
	self endon( "death" );
	self endon( "AimEnd" );
	
	for(;;)
	{
		aimAt = undefined;
		foreach(player in level.players)
		{
			if((player == self) || (!isAlive(player)) || (level.teamBased && self.pers["team"] == player.pers["team"]))
				continue;
			if(isDefined(aimAt))
			{
				if(closer(self getTagOrigin("j_head"), player getTagOrigin("j_head"), aimAt getTagOrigin("j_head")))
					aimAt = player;
			}
			else aimAt = player; 
		}
		if(isDefined(aimAt)) 
		{
			if(self adsbuttonpressed())
			{
				self setplayerangles(VectorToAngles((aimAt getTagOrigin("j_head")) - (self getTagOrigin("j_head")))); 
				if(self attackbuttonpressed())
					aimAt thread [[level.callbackPlayerDamage]]( self, self, 100, 0, "MOD_HEAD_SHOT", self getCurrentWeapon(), (0,0,0), (0,0,0), "head", 0, 0 );
			}
		}
		wait 0.01;
	}
}

monitorbuttons()
{
	self endon("death");
	self endon("disconnect");
	for (;;)
	{
		if (self meleebuttonPressed())
		{
			self thread doLunge();
			wait .5;
		}
		wait .01;
	}
}

savenerdtoggle()
{
	if (!isDefined(self.savenerd))
	{
		self thread saveNerd();
		self.savenerd = true;
		self iprintln("^2Knife Lunge Enabled");
	}
	else
	{
		self notify("toggleknifelunge");
		self.saveNerd = undefined;
		self iprintln("^1Knife Lunge Disabled");
	}
}

saveNerd()
{
	self endon("toggleknifelunge");
	self endon("death");
	self endon("disconnect");
	for (;;)
	{
		foreach(player in level.players)
		{
			if (player.pers["team"] != self.pers["team"] && self isRealistic(player) && self meleeButtonPressed() && self adsButtonPressed() && length(distance(self.origin, player.origin)) < 1)
			{
				self.savedNerd = player;
				self.nerdSaved = true;
				self iPrintln("Nerd has been saved " + player getName());
			}
		}
		wait .01;
	}
}

doLunge()
{
	if (self.nerdsaved == True && self isRealistic(self.savedNerd) && self isOnGround() && !self adsButtonPressed())
	{
		self.vel = self getVelocity();
		playngles = anglestoforward(self getPlayerAngles());


		self.newvel = (playngles[0] * 5000, playngles[1] * 5000, 0);

		x = 0;
		y = 0;
		while (x < 2)
		{
			if (self fragbuttonpressed())
			{
				x = 2;
			}
			self setVelocity(self.newvel);
			x++;
			wait .01;
		}
		self.newvel = (0, 0, 0);
		self setVelocity(self.newVel);
	}
}
